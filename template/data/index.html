<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  stroke: #fff;
  stroke-width: 1.5px;
}

path.link {
  fill: none;
  stroke: #666;
  stroke-width: 1px;
}
.link {
  fill: none;
  stroke: #000;
  stroke-width: 2px;
  stroke-opacity: .1;
}
.active_link {
  fill: none;
  stroke: #000;
  stroke-width: 2px;
  stroke-opacity: 1;
}

.link:hover {
  stroke-opacity: 1;
}

text {
  fill: #000;
  font: 10px sans-serif;
  pointer-events: none;
}
</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script>
var width = 1680,
    height = 768;
	
function getRandomColor() {
    var letters = '0123456789ABCDEF'.split('');
    var color = '#';
    for (var i = 0; i < 6; i++ ) {
        color += letters[Math.floor(Math.random() * 16)];
    }
    return color;
}
var activeNodeIndex = -1;
var activeLinkIndex=-1;
var translate,scale;
	//Data
	// Array of node objects (e.g. with a 'name' field here):
var nodes = []
// Array of links between the nodes:
// objects with 'source', 'target' node indices and a 'value' for the link weight:
var links = []
	//EndData
  // Some setup stuff.
var zoom = d3.behavior.zoom()
    .scaleExtent([0.1, 50])
    .on("zoom", zoomed);

var drag = d3.behavior.drag()
    .origin(function(d) { return d; })
    .on("dragstart", dragstarted)
    .on("drag", dragged)
    .on("dragend", dragended);
	

var color = d3.scale.category20();

var force = d3.layout.force()
    .charge(-150)
    .linkDistance(40)
    .size([width, height]);

var svg = d3.select("body").append("svg")
	.attr("width", width)
    .attr("height", height)
    .call(zoom)
	.on("dblclick.zoom", null);
var rect = svg.append("rect")
    .attr("width", width)
    .attr("height", height)
    .style("fill", "none")
	.style("stroke", "black")
	.style("stroke-width","2")
    .style("pointer-events", "all")
	.on('dblclick',function(){
		path.attr("class","link");
		activeLinkIndex=-1;
	  });	
var container = svg.append("g");
	
function zoomed() {
   if (activeNodeIndex==-1) {
  container.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
  }
}

function dragstarted(d) {
  d3.event.sourceEvent.stopPropagation();
  d3.select(this).classed("dragging", true);
}

function dragged(d) {  
  d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);
}

function dragended(d) {
  d3.select(this).classed("dragging", false);
}
	
  force
      .nodes(nodes)
      .links(links)
      .start();

// build the arrow.
container.append("svg:defs").selectAll("marker")
    .data(["end"])
  .enter().append("svg:marker")
    .attr("id", String)
    .attr("viewBox", "0 -5 10 10")
    .attr("refX", 15)
    .attr("refY", -1.5)
    .attr("markerWidth", 6)
    .attr("markerHeight", 6)
    .attr("orient", "auto")
  .append("svg:path")
    .attr("d", "M0,-5L10,0L0,5");
	
// add the links and the arrows
var path = container.append("svg:g").selectAll("path")
    .data(force.links())
  .enter().append("line")
    .attr("class", "link")	
	.style("stroke",function (d) {return d.color})
    .attr("marker-end", function(d) { if (d.direction) return "url(#end)"; else return ""})
	.attr("flow_id", function(d) { return d.flow_index})
	.on('mouseover',function(d) {
		if(d.flow_index!=undefined&&activeLinkIndex==-1) {
			path.attr("class", function (o) {
            return d.flow_index==o.flow_index? "active_link":"link";
        });
			
		}
	})
	.on('mouseout', function(d) { 
	if(activeLinkIndex==-1)
		path.attr("class","link")
	})
	.on('click', function(d) {
	activeLinkIndex=d.flow_index
	});
	  
  var nodes = container.selectAll(".node")
      .data(nodes)
    .enter().append("g");
	var node=nodes.append("circle")
      .attr("class", "node")
      .attr("r", 5)
      .style("fill",function (d) {			
				switch (d.type) {
					case "poll":
						return "#ffffff";
					break	
					case "vm":
						return "#0000ff";
					break	
					case "jms":
						return "#1ED2CC";
					break					
					default:
						return "#000000";
				}}              
            )		
      .call(force.drag)
	  .on('click', function(d){displayNodeInfo(d.name);})
	  .on('mousedown',function(d){
	  activeNodeIndex=this;
	  svg.on(".zoom", null);
	  })
	  .on('mouseup',function(d){
		activeNodeIndex=-1;
		svg.call(zoom).on("dblclick.zoom", null);
	  });
	//var text=nodes.append("text")
    //.attr("x", 12)
    //.attr("dy", ".35em")
    //.text(function(d) { return d.name; });

function displayNodeInfo(name){
    console.log(name);
}
	
  node.append("title")
      .text(function(d) { return d.name; });

  force.on("tick", function() {
    /*path.attr("d", function(d) {
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy);
        return "M" + 
            d.source.x + "," + 
            d.source.y + "A" + 
            dr + "," + dr + " 0 0,1 " + 
            d.target.x + "," + 
            d.target.y;
    });*/
	
	path.attr("x1", function(d) { return d.source.x; })
        .attr("y1", function(d) { return d.source.y; })
        .attr("x2", function(d) { return d.target.x; })
        .attr("y2", function(d) { return d.target.y; });
		
    node.attr("cx", function(d) { return d.x; })
        .attr("cy", function(d) { return d.y; });
	//text.attr("x", function(d) { return d.x+5; })
    //    .attr("y", function(d) { return d.y; });
  });

</script>